import fs from 'fs/promises';
import path from 'path';
import axios from 'axios';
import type {
  NormalizedDesignTokens,
  FigmaPluginOutput,
  FigmaOptions,
} from '@ds-cli/core';

/**
 * Generate Figma plugin manifest
 */
function generateManifest(name: string): any {
  return {
    name: name || 'Design System Token Importer',
    id: `${Date.now()}`,
    api: '1.0.0',
    main: 'code.js',
    ui: 'ui.html',
    editorType: ['figma'],
    networkAccess: {
      allowedDomains: ['none'],
    },
  };
}

/**
 * Generate Figma plugin code (code.js)
 */
function generatePluginCode(tokens: NormalizedDesignTokens): string {
  return `// Design System Token Importer
// Generated by @ds-cli/figma-bridge

const tokens = ${JSON.stringify(tokens, null, 2)};

// Show UI
figma.showUI(__html__, { width: 400, height: 600 });

// Handle import request
figma.ui.onmessage = async (msg) => {
  if (msg.type === 'import-tokens') {
    try {
      await importColors(tokens.colors);
      await importTypography(tokens.typography);
      figma.notify('‚úÖ Design tokens imported successfully!');
      figma.closePlugin();
    } catch (error) {
      figma.notify('‚ùå Error importing tokens: ' + error.message);
    }
  }

  if (msg.type === 'cancel') {
    figma.closePlugin();
  }
};

/**
 * Import color tokens as Figma styles
 */
async function importColors(colors: any) {
  for (const [scaleName, scale] of Object.entries(colors)) {
    for (const [weight, value] of Object.entries(scale as any)) {
      if (typeof value !== 'string') continue;

      const styleName = weight === 'DEFAULT'
        ? scaleName
        : \`\${scaleName}/\${weight}\`;

      // Check if style already exists
      let style = figma.getLocalPaintStyles().find(s => s.name === styleName);
      if (!style) {
        style = figma.createPaintStyle();
        style.name = styleName;
      }

      // Parse color and set paint
      const rgb = hexToRgb(value);
      if (rgb) {
        style.paints = [{
          type: 'SOLID',
          color: { r: rgb.r / 255, g: rgb.g / 255, b: rgb.b / 255 },
          opacity: rgb.a || 1,
        }];
      }
    }
  }
}

/**
 * Import typography tokens as Figma text styles
 */
async function importTypography(typography: any) {
  const { fontFamily, fontSize, fontWeight, lineHeight } = typography;

  for (const [name, size] of Object.entries(fontSize)) {
    const styleName = name;

    // Check if style already exists
    let style = figma.getLocalTextStyles().find(s => s.name === styleName);
    if (!style) {
      style = figma.createTextStyle();
      style.name = styleName;
    }

    // Parse font size
    const sizeValue = Array.isArray(size) ? size[0] : size;
    const numSize = parseFloat(sizeValue as string);

    if (!isNaN(numSize)) {
      style.fontSize = numSize;
    }

    // Set font family if available
    const family = fontFamily.sans?.[0] || 'Inter';
    const weight = fontWeight[name] || '400';

    try {
      await figma.loadFontAsync({ family, style: mapWeightToStyle(weight) });
      style.fontName = { family, style: mapWeightToStyle(weight) };
    } catch (e) {
      console.error(\`Failed to load font: \${family}\`, e);
    }

    // Set line height
    if (Array.isArray(size) && size[1]?.lineHeight) {
      const lh = parseFloat(size[1].lineHeight);
      if (!isNaN(lh)) {
        style.lineHeight = { value: lh, unit: 'PIXELS' };
      }
    } else if (lineHeight[name]) {
      const lh = parseFloat(lineHeight[name]);
      if (!isNaN(lh)) {
        style.lineHeight = { value: lh, unit: 'PIXELS' };
      }
    }
  }
}

/**
 * Convert hex color to RGB
 */
function hexToRgb(hex: string): { r: number; g: number; b: number; a?: number } | null {
  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);
  return result
    ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16),
      }
    : null;
}

/**
 * Map CSS font weight to Figma font style
 */
function mapWeightToStyle(weight: string): string {
  const weightMap: Record<string, string> = {
    '100': 'Thin',
    '200': 'ExtraLight',
    '300': 'Light',
    '400': 'Regular',
    '500': 'Medium',
    '600': 'SemiBold',
    '700': 'Bold',
    '800': 'ExtraBold',
    '900': 'Black',
  };

  return weightMap[weight] || 'Regular';
}
`;
}

/**
 * Generate Figma plugin UI (ui.html)
 */
function generatePluginUI(tokens: NormalizedDesignTokens): string {
  const colorCount = Object.keys(tokens.colors).length;
  const fontCount = Object.keys(tokens.typography.fontSize).length;

  return `<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Import Design Tokens</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      padding: 16px;
      background: #ffffff;
    }

    .header {
      margin-bottom: 24px;
    }

    h1 {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
      color: #000000;
    }

    .meta {
      font-size: 12px;
      color: #999999;
      margin-bottom: 4px;
    }

    .section {
      background: #f5f5f5;
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 16px;
    }

    .section-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 12px;
      color: #333333;
    }

    .token-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .token-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: #666666;
    }

    .token-count {
      background: #e0e0e0;
      border-radius: 4px;
      padding: 2px 8px;
      font-size: 12px;
      font-weight: 600;
      color: #333333;
    }

    .actions {
      display: flex;
      gap: 8px;
      margin-top: 24px;
    }

    button {
      flex: 1;
      padding: 12px;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: opacity 0.2s;
    }

    button:hover {
      opacity: 0.9;
    }

    .btn-primary {
      background: #18A0FB;
      color: white;
    }

    .btn-secondary {
      background: #f5f5f5;
      color: #333333;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Import Design Tokens</h1>
    <div class="meta">Source: ${tokens.meta.source}</div>
    <div class="meta">System: ${tokens.meta.system}</div>
  </div>

  <div class="section">
    <div class="section-title">üìä Token Summary</div>
    <div class="token-list">
      <div class="token-item">
        <span>üé® Colors:</span>
        <span class="token-count">${colorCount} scales</span>
      </div>
      <div class="token-item">
        <span>‚úçÔ∏è Typography:</span>
        <span class="token-count">${fontCount} styles</span>
      </div>
      <div class="token-item">
        <span>üìè Spacing:</span>
        <span class="token-count">${Object.keys(tokens.spacing).length} values</span>
      </div>
      <div class="token-item">
        <span>üîò Radius:</span>
        <span class="token-count">${Object.keys(tokens.borderRadius).length} values</span>
      </div>
    </div>
  </div>

  <div class="section">
    <div class="section-title">‚ÑπÔ∏è What will be imported</div>
    <div class="token-list">
      <div class="token-item">‚Ä¢ Color styles for all color scales</div>
      <div class="token-item">‚Ä¢ Text styles for all typography tokens</div>
      <div class="token-item">‚Ä¢ Styles will be created or updated</div>
    </div>
  </div>

  <div class="actions">
    <button class="btn-secondary" id="cancel">Cancel</button>
    <button class="btn-primary" id="import">Import Tokens</button>
  </div>

  <script>
    document.getElementById('import').onclick = () => {
      parent.postMessage({ pluginMessage: { type: 'import-tokens' } }, '*');
    };

    document.getElementById('cancel').onclick = () => {
      parent.postMessage({ pluginMessage: { type: 'cancel' } }, '*');
    };
  </script>
</body>
</html>
`;
}

/**
 * Push tokens to Figma via API
 */
async function pushToFigma(
  tokens: NormalizedDesignTokens,
  fileId: string,
  accessToken: string
): Promise<void> {
  const baseUrl = 'https://api.figma.com/v1';

  console.log('üîó Connecting to Figma API...');

  try {
    // Get file data
    const fileResponse = await axios.get(`${baseUrl}/files/${fileId}`, {
      headers: { 'X-Figma-Token': accessToken },
    });

    console.log('‚úÖ Connected to Figma file:', fileResponse.data.name);

    // Note: Figma API currently doesn't support creating styles programmatically
    // This would require a plugin or manual import
    console.log('‚ö†Ô∏è  Note: Figma API does not support programmatic style creation');
    console.log('üí° Use plugin generation mode instead: ds figma --mode plugin');
  } catch (error: any) {
    if (axios.isAxiosError(error)) {
      throw new Error(
        `Figma API error: ${error.response?.status} - ${error.response?.data?.err || error.message}`
      );
    }
    throw error;
  }
}

/**
 * Main figma bridge function
 */
export async function figma(options: FigmaOptions): Promise<void> {
  console.log(`üé® Starting Figma integration: ${options.mode} mode`);

  // Read normalized tokens
  const tokensData = await fs.readFile(options.input, 'utf-8');
  const tokens: NormalizedDesignTokens = JSON.parse(tokensData);

  if (options.mode === 'plugin') {
    console.log('üîå Generating Figma plugin...');

    // Generate plugin files
    const manifest = generateManifest('Design System Importer');
    const code = generatePluginCode(tokens);
    const ui = generatePluginUI(tokens);

    // Create output directory
    await fs.mkdir(options.out, { recursive: true });

    // Write plugin files
    await fs.writeFile(
      path.join(options.out, 'manifest.json'),
      JSON.stringify(manifest, null, 2)
    );
    await fs.writeFile(path.join(options.out, 'code.js'), code);
    await fs.writeFile(path.join(options.out, 'ui.html'), ui);

    console.log('‚úÖ Figma plugin generated!');
    console.log(`\nüì¶ Plugin files:`);
    console.log(`   ${path.join(options.out, 'manifest.json')}`);
    console.log(`   ${path.join(options.out, 'code.js')}`);
    console.log(`   ${path.join(options.out, 'ui.html')}`);
    console.log(`\nüöÄ Next steps:`);
    console.log(`   1. Open Figma Desktop`);
    console.log(`   2. Go to Plugins ‚Üí Development ‚Üí Import plugin from manifest`);
    console.log(`   3. Select the manifest.json file`);
    console.log(`   4. Run the plugin to import tokens`);
  } else if (options.mode === 'push') {
    if (!options.fileId || !options.token) {
      throw new Error('Figma file ID and access token required for push mode');
    }

    console.log('‚¨ÜÔ∏è  Pushing tokens to Figma via API...');
    await pushToFigma(tokens, options.fileId, options.token);
  }
}
