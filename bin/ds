#!/usr/bin/env node

const { Command } = require('commander');
const chalk = require('chalk');
const path = require('path');

// Import from built packages
const { extract, extractHtmlCommand, hardFork, TOKEN_SHIFT_PRESETS } = require(path.join(__dirname, '../packages/extractor/dist'));
const { normalize } = require(path.join(__dirname, '../packages/normalizer/dist'));
const { figma } = require(path.join(__dirname, '../packages/figma-bridge/dist'));
const { codegen, generateAssetPrompts } = require(path.join(__dirname, '../packages/codegen/dist'));

// Functional pipeline imports (Phases 9-12)
const { trace } = require(path.join(__dirname, '../packages/functional-trace/dist'));
const { flows } = require(path.join(__dirname, '../packages/functional-flows/dist'));
const { entities } = require(path.join(__dirname, '../packages/functional-entities/dist'));
const { extractRules } = require(path.join(__dirname, '../packages/functional-rules/dist'));
const { generateCode } = require(path.join(__dirname, '../packages/functional-codegen/dist'));

const program = new Command();

program
  .name('ds')
  .description('Design System CLI - Extract, normalize, and generate code from design systems')
  .version('1.0.0');

program
  .command('extract')
  .description('Extract design tokens from a website using Playwright')
  .requiredOption('-u, --url <url>', 'URL to extract from')
  .option('-o, --out <path>', 'Output JSON file path', './tokens-raw.json')
  .option('--assets-out <path>', 'Assets context output path (optional)')
  .option('-s, --screenshots <dir>', 'Directory to save screenshots')
  .option('--viewport <viewport>', 'Viewport size (e.g., "1440x900")', '1440x900')
  .option('--no-headless', 'Run browser in visible mode')
  .option('--timeout <ms>', 'Navigation timeout in milliseconds', '60000')
  .action(async (options) => {
    try {
      await extract({
        url: options.url,
        out: options.out,
        assetsOut: options.assetsOut,
        screenshots: options.screenshots,
        viewport: options.viewport,
        headless: options.headless,
        timeout: parseInt(options.timeout),
      });
    } catch (error) {
      console.error(chalk.red('‚ùå Extraction failed:'), error.message);
      process.exit(1);
    }
  });

program
  .command('normalize')
  .description('Normalize raw design tokens to house system format')
  .requiredOption('-i, --input <path>', 'Input raw tokens JSON file')
  .option('-m, --map <path>', 'Token mapping configuration file', './token-mapping.json')
  .option('-o, --out <path>', 'Output normalized tokens file', './tokens-normalized.json')
  .action(async (options) => {
    try {
      await normalize({
        input: options.input,
        map: options.map,
        out: options.out,
      });
    } catch (error) {
      console.error(chalk.red('‚ùå Normalization failed:'), error.message);
      process.exit(1);
    }
  });

program
  .command('figma')
  .description('Generate Figma plugin or push tokens via API')
  .requiredOption('-i, --input <path>', 'Input normalized tokens JSON file')
  .option('-o, --out <path>', 'Output directory for plugin files', './figma-plugin')
  .option('--mode <mode>', 'Mode: plugin or push', 'plugin')
  .option('--file-id <id>', 'Figma file ID (for push mode)')
  .option('--token <token>', 'Figma access token (for push mode)')
  .action(async (options) => {
    try {
      await figma({
        input: options.input,
        out: options.out,
        mode: options.mode,
        fileId: options.fileId,
        token: options.token,
      });
    } catch (error) {
      console.error(chalk.red('‚ùå Figma integration failed:'), error.message);
      process.exit(1);
    }
  });

program
  .command('codegen')
  .description('Generate React, Tailwind, or MUI code from tokens')
  .requiredOption('-i, --input <path>', 'Input normalized tokens JSON file')
  .option('-o, --out <path>', 'Output directory for generated code', './design-system')
  .option('-f, --framework <framework>', 'Framework: react-tailwind, react-mui, vue-tailwind, svelte-tailwind', 'react-tailwind')
  .action(async (options) => {
    try {
      await codegen({
        input: options.input,
        out: options.out,
        framework: options.framework,
      });
    } catch (error) {
      console.error(chalk.red('‚ùå Code generation failed:'), error.message);
      process.exit(1);
    }
  });

program
  .command('assets-prompts')
  .description('Generate asset recreation prompts from assets.json')
  .requiredOption('--assets <file>', 'Path to assets.json')
  .requiredOption('--out <file>', 'Path to write asset-prompts.json')
  .action(async (opts) => {
    try {
      await generateAssetPrompts(opts.assets, opts.out);
      console.log(chalk.green(`‚úì Wrote asset prompts to ${opts.out}`));
    } catch (err) {
      console.error(chalk.red('Error generating asset prompts'), err);
      process.exit(1);
    }
  });

program
  .command('extract-html')
  .description('Extract complete HTML structure and generate React components')
  .requiredOption('-u, --url <url>', 'URL to extract from')
  .option('-o, --out <path>', 'Output directory', './html-extracted')
  .option('--no-assets', 'Skip downloading assets')
  .option('--no-components', 'Skip generating components')
  .action(async (options) => {
    try {
      await extractHtmlCommand({
        url: options.url,
        out: options.out,
        downloadAssets: options.assets,
        generateComponents: options.components
      });
    } catch (error) {
      console.error(chalk.red('‚ùå HTML extraction failed:'), error.message);
      process.exit(1);
    }
  });

program
  .command('hard-fork')
  .description('Transform extracted site into legally clean, brand-neutral template')
  .requiredOption('-s, --source <dir>', 'Source directory (from extract-html)')
  .option('-o, --out <dir>', 'Output directory (default: source-fork)')
  .option('--brand-names <names>', 'Comma-separated brand names to remove')
  .option('--company-name <name>', 'Replacement company name', 'InsightPulse')
  .option('--product-name <name>', 'Replacement product name', 'Product Name')
  .option('--preset <preset>', 'Token shift preset: subtle, moderate, dramatic, insightpulse', 'moderate')
  .option('--hue-shift <degrees>', 'Custom hue shift in degrees (-180 to 180)')
  .option('--saturation <multiplier>', 'Custom saturation multiplier (0.5 to 2.0)')
  .option('--skip-brands', 'Skip brand name stripping')
  .option('--skip-tokens', 'Skip token shifting')
  .option('--skip-rename', 'Skip component renaming')
  .option('--tokens-path <path>', 'Path to tokens file (if not auto-detected)')
  .action(async (options) => {
    try {
      const brandNames = options.brandNames ? options.brandNames.split(',').map(n => n.trim()) : undefined;

      let tokenConfig = TOKEN_SHIFT_PRESETS[options.preset] || TOKEN_SHIFT_PRESETS.moderate;

      // Custom overrides
      if (options.hueShift || options.saturation) {
        tokenConfig = {
          ...tokenConfig,
          colorShift: {
            hueShift: options.hueShift ? parseInt(options.hueShift) : tokenConfig.colorShift?.hueShift,
            saturationMultiplier: options.saturation ? parseFloat(options.saturation) : tokenConfig.colorShift?.saturationMultiplier
          }
        };
      }

      await hardFork({
        sourceDir: options.source,
        outputDir: options.out,
        brandConfig: {
          brandNames,
          companyName: options.companyName,
          productName: options.productName
        },
        tokenConfig,
        skipBrandStripping: options.skipBrands,
        skipTokenShifting: options.skipTokens,
        skipComponentRenaming: options.skipRename,
        tokensPath: options.tokensPath
      });
    } catch (error) {
      console.error(chalk.red('‚ùå Hard fork failed:'), error.message);
      console.error(error.stack);
      process.exit(1);
    }
  });

program
  .command('pipeline')
  .description('Run the full extraction ‚Üí normalization ‚Üí figma ‚Üí codegen pipeline')
  .requiredOption('-u, --url <url>', 'URL to extract from')
  .option('--raw-out <path>', 'Raw tokens output path', './tokens-raw.json')
  .option('--normalized-out <path>', 'Normalized tokens output path', './tokens-normalized.json')
  .option('--assets-out <path>', 'Assets context output path', './assets.json')
  .option('--map <path>', 'Token mapping configuration file', './token-mapping.json')
  .option('--figma-out <path>', 'Figma plugin output directory', './figma-plugin')
  .option('--code-out <path>', 'Code generation output directory', './design-system')
  .option('--framework <framework>', 'Framework for codegen: react-tailwind, react-mui, vue-tailwind, svelte-tailwind', 'react-tailwind')
  .action(async (options) => {
    console.log(chalk.bold.cyan('\nüöÄ Starting full design system pipeline...\n'));

    try {
      console.log(chalk.bold('üìç Step 1/4: Extracting design tokens...'));
      await extract({
        url: options.url,
        out: options.rawOut,
        assetsOut: options.assetsOut,
        headless: true,
      });

      console.log(chalk.bold('\nüìç Step 2/4: Normalizing tokens...'));
      await normalize({
        input: options.rawOut,
        map: options.map,
        out: options.normalizedOut,
      });

      console.log(chalk.bold('\nüìç Step 3/4: Generating Figma plugin...'));
      await figma({
        input: options.normalizedOut,
        out: options.figmaOut,
        mode: 'plugin',
      });

      console.log(chalk.bold('\nüìç Step 4/4: Generating code...'));
      await codegen({
        input: options.normalizedOut,
        out: options.codeOut,
        framework: options.framework,
      });

      console.log(chalk.bold.green('\n‚úÖ Pipeline complete!\n'));
      console.log(chalk.cyan('üì¶ Output files:'));
      console.log(`   Raw tokens: ${options.rawOut}`);
      console.log(`   Normalized tokens: ${options.normalizedOut}`);
      console.log(`   Figma plugin: ${options.figmaOut}/`);
      console.log(`   Generated code: ${options.codeOut}/`);
    } catch (error) {
      console.error(chalk.red('\n‚ùå Pipeline failed:'), error.message);
      console.error(error.stack);
      process.exit(1);
    }
  });

// Functional pipeline commands (Phases 9-11)
program
  .command('trace')
  .description('Record user interactions and network calls (Phase 9)')
  .requiredOption('-u, --url <url>', 'URL to trace')
  .option('-o, --out <path>', 'Output trace file', './trace.json')
  .option('--duration <ms>', 'Recording duration in milliseconds', '30000')
  .option('--viewport <size>', 'Viewport size (e.g., "1440x900")', '1440x900')
  .action(async (options) => {
    try {
      const [width, height] = options.viewport.split('x').map(Number);

      await trace({
        url: options.url,
        out: options.out,
        duration: parseInt(options.duration),
        viewport: [width, height]
      });
    } catch (error) {
      console.error(chalk.red('‚ùå Trace recording failed:'), error.message);
      process.exit(1);
    }
  });

program
  .command('flows')
  .description('Extract screens and flows from trace (Phase 10)')
  .requiredOption('--trace <path>', 'Input trace file')
  .option('--out-screens <path>', 'Output screens file', './screens.json')
  .option('--out-flows <path>', 'Output flows file', './flows.json')
  .option('--min-steps <number>', 'Minimum steps for flow detection', '2')
  .action(async (options) => {
    try {
      await flows({
        tracePath: options.trace,
        outScreens: options.outScreens,
        outFlows: options.outFlows,
        minStepsForFlow: parseInt(options.minSteps)
      });
    } catch (error) {
      console.error(chalk.red('‚ùå Flow extraction failed:'), error.message);
      process.exit(1);
    }
  });

program
  .command('entities')
  .description('Extract entities and data models from trace (Phase 11)')
  .requiredOption('--trace <path>', 'Input trace file')
  .option('-o, --out <path>', 'Output entities file', './entities.json')
  .option('--no-metadata', 'Exclude metadata from output')
  .action(async (options) => {
    try {
      await entities({
        tracePath: options.trace,
        out: options.out,
        includeMetadata: options.metadata
      });
    } catch (error) {
      console.error(chalk.red('‚ùå Entity extraction failed:'), error.message);
      process.exit(1);
    }
  });

program
  .command('rules')
  .description('Extract business rules and state machines (Phase 12)')
  .requiredOption('--trace <path>', 'Input trace file')
  .requiredOption('--flows <path>', 'Input flows file')
  .requiredOption('--entities <path>', 'Input entities file')
  .option('-o, --out <path>', 'Output rules file', './rules.json')
  .option('--llm-profile <profile>', 'LLM profile for enhancement (optional)')
  .option('--no-metadata', 'Exclude metadata from output')
  .action(async (options) => {
    try {
      await extractRules({
        tracePath: options.trace,
        flowsPath: options.flows,
        entitiesPath: options.entities,
        out: options.out,
        llmProfile: options.llmProfile,
        includeMetadata: options.metadata
      });
    } catch (error) {
      console.error(chalk.red('‚ùå Rules extraction failed:'), error.message);
      process.exit(1);
    }
  });

program
  .command('fx-codegen')
  .description('Generate functional application scaffold (Phase 12)')
  .requiredOption('--screens <path>', 'Input screens file')
  .requiredOption('--flows <path>', 'Input flows file')
  .requiredOption('--entities <path>', 'Input entities file')
  .requiredOption('--rules <path>', 'Input rules file')
  .option('--framework <framework>', 'Target framework', 'nextjs')
  .option('-o, --out <path>', 'Output directory', './apps/functional-app')
  .action(async (options) => {
    try {
      await generateCode({
        screensPath: options.screens,
        flowsPath: options.flows,
        entitiesPath: options.entities,
        rulesPath: options.rules,
        framework: options.framework,
        out: options.out
      });
    } catch (error) {
      console.error(chalk.red('‚ùå Code generation failed:'), error.message);
      process.exit(1);
    }
  });

program.parse(process.argv);

if (!process.argv.slice(2).length) {
  program.outputHelp();
}
